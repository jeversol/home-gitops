apiVersion: v1
kind: ConfigMap
metadata:
  name: renovate-webhook-scripts
  namespace: renovate
  labels:
    app.kubernetes.io/name: renovate-webhook
    app.kubernetes.io/part-of: renovate
data:
  renovate-dependency-dashboard.sh: |
    #!/bin/sh
    set -eu

    log() {
      printf '%s | delivery=%s | %s\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" "${x_github_delivery:-unknown}" "$1"
    }

    bail() {
      log "error: $1"
      exit 1
    }

    PAYLOAD="${1:-}"
    [ -n "$PAYLOAD" ] || bail "missing payload"

    [ -n "${GITHUB_SECRET:-}" ] || bail "GITHUB_SECRET not set"

    SIGNATURE_HEADER="${x_hub_signature_256:-}"
    [ -n "$SIGNATURE_HEADER" ] || bail "missing X-Hub-Signature-256 header"

    CALCULATED_SIGNATURE="sha256=$(printf '%s' "$PAYLOAD" | openssl dgst -sha256 -hmac "$GITHUB_SECRET" | sed 's/^.* //')"
    [ "$CALCULATED_SIGNATURE" = "$SIGNATURE_HEADER" ] || bail "signature mismatch"

    EVENT="${x_github_event:-}"
    ACTION=$(printf '%s' "$PAYLOAD" | jq -r '.action // empty')
    SENDER_TYPE=$(printf '%s' "$PAYLOAD" | jq -r '.sender.type // empty')
    SENDER_LOGIN=$(printf '%s' "$PAYLOAD" | jq -r '.sender.login // ""')
    log "parsed event=$EVENT action=$ACTION sender=$SENDER_LOGIN type=$SENDER_TYPE"

    case "$SENDER_TYPE" in
      User|Bot) ;;
      *)
        log "sender type $SENDER_TYPE not allowed"
        exit 0
        ;;
    esac

    case "$EVENT" in
      issues)
        # Issue edits should only be processed by users, not the bot
        if [ "$SENDER_LOGIN" = "${RENOVATE_BOT_LOGIN:-harry-botter-lumos[bot]}" ]; then
          log "ignored issue edit from bot $SENDER_LOGIN"
          exit 0
        fi

        if [ "$ACTION" != "edited" ]; then
          log "ignored issue action $ACTION"
          exit 0
        fi

        TITLE=$(printf '%s' "$PAYLOAD" | jq -r '.issue.title // empty')
        log "issue title=$TITLE"
        if [ "$TITLE" != "Dependency Dashboard" ]; then
          log "ignored issue title $TITLE"
          exit 0
        fi

        NEW_BODY_TEXT=$(printf '%s' "$PAYLOAD" | jq -r '.issue.body // ""')
        OLD_BODY_TEXT=$(printf '%s' "$PAYLOAD" | jq -r '.changes.body.from // ""')
        ;;

      pull_request)
        PR_BRANCH=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.head.ref // ""')
        log "pull_request branch=$PR_BRANCH action=$ACTION"

        case "$PR_BRANCH" in
          renovate/*) ;;
          *)
            log "ignored pull_request branch $PR_BRANCH"
            exit 0
            ;;
        esac

        # Handle PR opened events for notifications
        if [ "$ACTION" = "opened" ]; then
          PR_ASSIGNEES=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.assignees | length')

          # Only notify if PR has assignees (manual review required)
          if [ "$PR_ASSIGNEES" -gt 0 ]; then
            PR_TITLE=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.title // "Renovate PR"')
            PR_URL=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.html_url // ""')
            PR_NUMBER=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.number // ""')

            log "sending notifications for PR #$PR_NUMBER"

            # Send Pushover notification
            if [ -n "${PUSHOVER_API_TOKEN:-}" ] && [ -n "${PUSHOVER_USER_KEY:-}" ]; then
              PUSHOVER_RESPONSE=$(curl -sS -w "\n%{http_code}" \
                --form-string "token=$PUSHOVER_API_TOKEN" \
                --form-string "user=$PUSHOVER_USER_KEY" \
                --form-string "title=Renovate PR #$PR_NUMBER" \
                --form-string "message=$PR_TITLE" \
                --form-string "url=$PR_URL" \
                --form-string "url_title=View PR" \
                --form-string "priority=0" \
                https://api.pushover.net/1/messages.json 2>&1)
              PUSHOVER_STATUS=$(echo "$PUSHOVER_RESPONSE" | tail -n1)
              if [ "$PUSHOVER_STATUS" = "200" ]; then
                log "pushover notification sent successfully"
              else
                log "pushover notification failed with status $PUSHOVER_STATUS"
              fi
            else
              log "pushover credentials not configured, skipping"
            fi

            # Send Discord notification
            if [ -n "${DISCORD_WEBHOOK_URL:-}" ]; then
              DISCORD_MESSAGE=$(jq -n \
                --arg title "$PR_TITLE" \
                --arg url "$PR_URL" \
                --arg number "$PR_NUMBER" \
                '{
                  content: ("**Renovate PR #" + $number + "**\n" + $title + "\n" + $url)
                }')

              DISCORD_RESPONSE=$(curl -sS -w "\n%{http_code}" \
                -H "Content-Type: application/json" \
                -d "$DISCORD_MESSAGE" \
                "$DISCORD_WEBHOOK_URL" 2>&1)
              DISCORD_STATUS=$(echo "$DISCORD_RESPONSE" | tail -n1)
              if [ "$DISCORD_STATUS" = "204" ] || [ "$DISCORD_STATUS" = "200" ]; then
                log "discord notification sent successfully"
              else
                log "discord notification failed with status $DISCORD_STATUS"
              fi
            else
              log "discord webhook not configured, skipping"
            fi
          else
            log "PR has no assignees, skipping notifications (auto-merge PR)"
          fi

          log "notification handling complete"
          exit 0
        fi

        # Handle PR close/merge events
        if [ "$ACTION" = "closed" ]; then
          PR_MERGED=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.merged // false')
          log "pull_request closed merged=$PR_MERGED"
          if [ "$PR_MERGED" = "true" ]; then
            log "renovate PR merged, triggering run"
            SKIP_CHECKBOX_CHECK="true"
          else
            log "ignored pull_request close without merge"
            exit 0
          fi
        elif [ "$ACTION" = "edited" ]; then
          # Block bot from checkbox toggle logic to prevent false triggers
          if [ "$SENDER_LOGIN" = "${RENOVATE_BOT_LOGIN:-harry-botter-lumos[bot]}" ]; then
            log "ignored PR edit from bot $SENDER_LOGIN"
            exit 0
          fi

          NEW_BODY_TEXT=$(printf '%s' "$PAYLOAD" | jq -r '.pull_request.body // ""')
          OLD_BODY_TEXT=$(printf '%s' "$PAYLOAD" | jq -r '.changes.body.from // ""')
          if [ -z "$OLD_BODY_TEXT" ]; then
            log "pull_request change did not include previous body"
            exit 0
          fi
          SKIP_CHECKBOX_CHECK="false"
        else
          log "ignored pull_request action $ACTION"
          exit 0
        fi
        ;;

      *)
        log "ignored event $EVENT"
        exit 0
        ;;
    esac

    # Check for checkbox toggle (skip if PR was merged)
    if [ "${SKIP_CHECKBOX_CHECK:-false}" = "false" ]; then
      log "new body length=$(printf '%s' "$NEW_BODY_TEXT" | wc -c) old body length=$(printf '%s' "$OLD_BODY_TEXT" | wc -c)"

      if jq -n \
        --arg old "$OLD_BODY_TEXT" \
        --arg new "$NEW_BODY_TEXT" \
        '
          def lines($t): ($t | split("\n"));
          def norm($line): ($line | sub("^\\s*"; "") | ascii_downcase);
          def unchecked($line): norm($line) | test("^(\\-|\\*) \\[ \\]");
          def checked($line): norm($line) | test("^(\\-|\\*) \\[(x|\\*)\\]");

          lines($old) as $oldLines |
          lines($new) as $newLines |
          ([$oldLines|length, $newLines|length] | min) as $len |
          any(
            range(0; $len);
            ($oldLines[.] // "") as $o |
            ($newLines[.] // "") as $n |
            $o != $n and unchecked($o) and checked($n)
          )
        ' >/dev/null; then
        log "checkbox toggled in body"
      else
        log "no checkbox toggled from unchecked to checked"
        exit 0
      fi
    fi

    API_SERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
    SERVICE_ACCOUNT_TOKEN_PATH="/var/run/secrets/kubernetes.io/serviceaccount/token"
    CA_CERT_PATH="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

    [ -f "$SERVICE_ACCOUNT_TOKEN_PATH" ] || bail "service account token not found"
    [ -f "$CA_CERT_PATH" ] || bail "cluster CA bundle not found"

    TOKEN=$(cat "$SERVICE_ACCOUNT_TOKEN_PATH")

    CRONJOB_NAMESPACE="${CRONJOB_NAMESPACE:-renovate}"
    CRONJOB_NAME="${CRONJOB_NAME:-renovate}"
    JOB_TTL_RAW="${RENOVATE_JOB_TTL_SECONDS:-900}"

    if printf '%s' "$JOB_TTL_RAW" | grep -Eq '^[0-9]+$'; then
      JOB_TTL="$JOB_TTL_RAW"
    else
      JOB_TTL="0"
    fi

    CRONJOB_RESPONSE=$(curl -fsS \
      --cacert "$CA_CERT_PATH" \
      --header "Authorization: Bearer $TOKEN" \
      "$API_SERVER/apis/batch/v1/namespaces/${CRONJOB_NAMESPACE}/cronjobs/${CRONJOB_NAME}") || bail "failed to fetch cronjob ${CRONJOB_NAMESPACE}/${CRONJOB_NAME}"

    EXISTING_WEBHOOK_JOBS=$(curl -fsS \
      --cacert "$CA_CERT_PATH" \
      --header "Authorization: Bearer $TOKEN" \
      "$API_SERVER/apis/batch/v1/namespaces/${CRONJOB_NAMESPACE}/jobs?labelSelector=recompiled.org%2Frenovate-trigger%3Dwebhook") || bail "failed to list webhook jobs"

    if printf '%s' "$EXISTING_WEBHOOK_JOBS" | jq -e 'any(.items[]?; (.metadata.deletionTimestamp | not) and ((.status.active // 0) > 0 or (.status.completionTime == null)))' >/dev/null; then
      log "skipping trigger; webhook job already running"
      exit 0
    fi

    DELIVERY_SLUG=$(printf '%s' "${x_github_delivery:-$(date -u '+%s')}" | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9' | cut -c1-20)
    [ -n "$DELIVERY_SLUG" ] || DELIVERY_SLUG=$(date -u '+%Y%m%d%H%M%S')

    JOB_NAME="renovate-triggered-${DELIVERY_SLUG}"

    log "triggering job candidate ${JOB_NAME}"

    JOB_PAYLOAD=$(printf '%s' "$CRONJOB_RESPONSE" | jq \
      --arg name "$JOB_NAME" \
      --argjson ttl "$JOB_TTL" \
      --arg delivery "${x_github_delivery:-}" \
      --arg event "$EVENT" \
      --arg action "$ACTION" \
      --arg sender "$SENDER_TYPE" \
      '
      .metadata.namespace as $ns |
      {
        apiVersion: "batch/v1",
        kind: "Job",
        metadata: {
          name: $name,
          namespace: $ns,
          labels: ((.spec.jobTemplate.metadata.labels // .metadata.labels // {}) 
            + {"recompiled.org/renovate-trigger": "webhook", "recompiled.org/renovate-source": "dependency-dashboard"}),
          annotations: ((.spec.jobTemplate.metadata.annotations // {})
            + (if ($delivery // "") != "" then {"recompiled.org/github-delivery": $delivery} else {} end)
            + (if ($event // "") != "" then {"recompiled.org/github-event": $event} else {} end)
            + (if ($action // "") != "" then {"recompiled.org/github-action": $action} else {} end)
            + (if ($sender // "") != "" then {"recompiled.org/github-sender": $sender} else {} end))
        },
        spec: .spec.jobTemplate.spec
      }
      | if $ttl > 0 then .spec.ttlSecondsAfterFinished = $ttl else . end
    ')
    [ -n "$JOB_PAYLOAD" ] || bail "failed to build job payload"

    HTTP_STATUS=$(printf '%s' "$JOB_PAYLOAD" | curl -sS -o /tmp/job-response.json -w '%{http_code}' \
      --cacert "$CA_CERT_PATH" \
      --header "Authorization: Bearer $TOKEN" \
      --header 'Content-Type: application/json' \
      --data @- \
      "$API_SERVER/apis/batch/v1/namespaces/${CRONJOB_NAMESPACE}/jobs") || bail "failed to submit job"

    if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
      log "created job $JOB_NAME (status $HTTP_STATUS)"
      cat /tmp/job-response.json
    else
      ERR_MSG=$(cat /tmp/job-response.json)
      bail "API returned status $HTTP_STATUS: $ERR_MSG"
    fi
