---
apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
  namespace: o11y
data:
  config.alloy: |
    // Discover Kubernetes API server
    discovery.kubernetes "api_server" {
      role = "endpoints"
      namespaces {
        names = ["default"]
      }
    }

    // Discover kubelet metrics
    discovery.kubernetes "kubelet" {
      role = "node"
    }

    // Discover pods for container metrics
    discovery.kubernetes "pods" {
      role = "pod"
    }

    // Discover services for service discovery
    discovery.kubernetes "services" {
      role = "service"
    }

    // Discover services with Prometheus annotations
    discovery.kubernetes "annotated_services" {
      role = "service"
    }

    // Discover kube-state-metrics service
    discovery.kubernetes "kube_state_metrics" {
      role = "service"
      namespaces {
        names = ["o11y"]
      }
    }

    // Scrape kubelet metrics
    prometheus.scrape "kubelet" {
      targets = discovery.kubernetes.kubelet.targets
      forward_to = [prometheus.remote_write.mimir.receiver]
      
      job_name = "kubelet"
      scheme = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }
      
      scrape_interval = "30s"
      metrics_path = "/metrics"
    }

    // Scrape kubelet cadvisor metrics (container metrics)
    prometheus.scrape "kubelet_cadvisor" {
      targets = discovery.kubernetes.kubelet.targets
      forward_to = [prometheus.remote_write.mimir.receiver]
      
      job_name = "kubelet-cadvisor"
      scheme = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }
      
      scrape_interval = "30s"
      metrics_path = "/metrics/cadvisor"
      
      // Drop high-cardinality container histogram buckets
      metric_relabel_configs = [
        {
          source_labels = ["__name__"]
          regex = "container_.*_bucket|container_fs_.*_bucket|container_memory_.*_bucket|container_cpu_.*_bucket"
          action = "drop"
        }
      ]
    }

    // Scrape API server metrics
    prometheus.scrape "api_server" {
      targets = discovery.kubernetes.api_server.targets
      forward_to = [prometheus.remote_write.mimir.receiver]
      
      job_name = "apiserver"
      scheme = "https"
      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        insecure_skip_verify = true
      }
      
      scrape_interval = "30s"
      
      // Drop high-cardinality API server histogram buckets
      metric_relabel_configs = [
        {
          source_labels = ["__name__"]
          regex = "apiserver_request_duration_seconds_bucket|apiserver_request_size_bytes_bucket|apiserver_response_size_bytes_bucket|apiserver_.*_bucket"
          action = "drop"
        }
      ]
    }

    // Scrape kube-state-metrics
    prometheus.scrape "kube_state_metrics" {
      targets = discovery.relabel.kube_state_metrics.output
      forward_to = [prometheus.remote_write.mimir.receiver]
      
      job_name = "kube-state-metrics"
      scrape_interval = "30s"
      metrics_path = "/metrics"
    }

    // Discover pods with Prometheus annotations
    discovery.kubernetes "annotated_pods" {
      role = "pod"
    }

    // Scrape pods that have prometheus.io/scrape=true annotation
    prometheus.scrape "annotated_pods" {
      targets = discovery.relabel.annotated_pods.output
      forward_to = [prometheus.remote_write.mimir.receiver]
      scrape_interval = "30s"
      
      // Drop common histogram buckets from all pods
      metric_relabel_configs = [
        {
          source_labels = ["__name__"]
          regex = ".*_duration_seconds_bucket|.*_request_size_bytes_bucket|.*_response_size_bytes_bucket|.*_bucket"
          action = "drop"
        }
      ]
    }

    // Scrape services that have prometheus.io/scrape=true annotation
    prometheus.scrape "annotated_services" {
      targets = discovery.relabel.annotated_services.output
      forward_to = [prometheus.remote_write.mimir.receiver]
      scrape_interval = "30s"
      
      // Drop common histogram buckets from all services
      metric_relabel_configs = [
        {
          source_labels = ["__name__"]
          regex = ".*_duration_seconds_bucket|.*_request_size_bytes_bucket|.*_response_size_bytes_bucket|.*_bucket"
          action = "drop"
        }
      ]
    }

    // Relabel to only scrape annotated pods and use their annotations
    discovery.relabel "annotated_pods" {
      targets = discovery.kubernetes.annotated_pods.targets

      // Only scrape pods with prometheus.io/scrape=true
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
        action = "keep"
        regex = "true"
      }

      // Use custom metrics path if specified
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
        action = "replace"
        target_label = "__metrics_path__"
        regex = "(.+)"
      }

      // Use custom port if specified
      rule {
        source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
        action = "replace"
        regex = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement = "$1:$2"
        target_label = "__address__"
      }

      // Add job name based on pod labels (try both label formats)
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        action = "replace"
        target_label = "job"
        regex = "(.+)"
      }
      
      // Fallback to simple app label for Flux controllers
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app"]
        action = "replace"
        target_label = "job"
        regex = "(.+)"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action = "replace"
        target_label = "namespace"
      }

      // Add pod name label
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action = "replace"
        target_label = "pod"
      }

      // Add node name label for node-exporter pods
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        action = "replace"
        target_label = "node"
      }
    }

    // Relabel to only scrape annotated services and use their annotations
    discovery.relabel "annotated_services" {
      targets = discovery.kubernetes.annotated_services.targets

      // Only scrape services with prometheus.io/scrape=true
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_scrape"]
        action = "keep"
        regex = "true"
      }

      // Use custom metrics path if specified
      rule {
        source_labels = ["__meta_kubernetes_service_annotation_prometheus_io_path"]
        action = "replace"
        target_label = "__metrics_path__"
        regex = "(.+)"
      }

      // Use custom port if specified
      rule {
        source_labels = ["__address__", "__meta_kubernetes_service_annotation_prometheus_io_port"]
        action = "replace"
        regex = "([^:]+)(?::\\d+)?;(\\d+)"
        replacement = "$1:$2"
        target_label = "__address__"
      }

      // Add job name based on service name
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        action = "replace"
        target_label = "job"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action = "replace"
        target_label = "namespace"
      }
    }

    // Relabel kube-state-metrics service
    discovery.relabel "kube_state_metrics" {
      targets = discovery.kubernetes.kube_state_metrics.targets

      // Only scrape kube-state-metrics service
      rule {
        source_labels = ["__meta_kubernetes_service_name"]
        action = "keep"
        regex = "kube-state-metrics"
      }

      // Set address to service endpoint (port 8080)
      rule {
        source_labels = ["__address__"]
        action = "replace"
        target_label = "__address__"
        regex = "([^:]+)(?::\\d+)?"
        replacement = "$1:8080"
      }

      // Add cluster label
      rule {
        target_label = "cluster"
        replacement = "home-cluster"
      }
    }

    // Discover Longhorn manager pods directly for per-node metrics
    discovery.kubernetes "longhorn_pods" {
      role = "pod"
      namespaces {
        names = ["longhorn"]
      }
    }

    // Scrape Longhorn manager pods individually for accurate per-node data
    prometheus.scrape "longhorn_managers" {
      targets = discovery.relabel.longhorn_managers.output
      forward_to = [prometheus.remote_write.mimir.receiver]
      
      job_name = "longhorn-manager"
      scrape_interval = "30s"
      metrics_path = "/metrics"
      
      // Drop Longhorn histogram buckets
      metric_relabel_configs = [
        {
          source_labels = ["__name__"]
          regex = "longhorn_.*_bucket|longhorn_.*_duration_seconds_bucket"
          action = "drop"
        }
      ]
    }

    // Relabel to only scrape longhorn-manager pods
    discovery.relabel "longhorn_managers" {
      targets = discovery.kubernetes.longhorn_pods.targets

      // Only scrape longhorn-manager pods
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action = "keep"
        regex = "longhorn-manager-.*"
      }

      // Set address to pod IP + port 9500
      rule {
        source_labels = ["__meta_kubernetes_pod_ip"]
        action = "replace"
        target_label = "__address__"
        replacement = "$1:9500"
      }

      // Add cluster label
      rule {
        target_label = "cluster"
        replacement = "home-cluster"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        action = "replace"
        target_label = "namespace"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        action = "replace"
        target_label = "node"
      }

      // Add pod label
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        action = "replace"
        target_label = "pod"
      }
    }

    // Remote write to Mimir
    prometheus.remote_write "mimir" {
      endpoint {
        url = "http://mimir-nginx.o11y.svc:80/api/v1/push"
      }
      
      // Add cluster label to all metrics
      external_labels = {
        cluster = "home-cluster",
      }
    }

    // Log collection - discover pods for log scraping
    discovery.kubernetes "pod_logs" {
      role = "pod"
    }

    // Scrape container logs
    loki.source.kubernetes "pod_logs" {
      targets    = discovery.kubernetes.pod_logs.targets
      forward_to = [loki.write.loki.receiver]
    }

    // Remote write to Loki
    loki.write "loki" {
      endpoint {
        url = "http://loki.o11y.svc:3100/loki/api/v1/push"
        headers = {
          "X-Scope-OrgID" = "1",
        }
      }
      
      // Add cluster label to all logs
      external_labels = {
        cluster = "home-cluster",
      }
    }
